# Core configuration options and defaults for hammer-vlsi.
# The values specified in this file are the defaults.
# e.g. foo: "bar" in this file means that the default setting for foo is "bar".

vlsi.core:
  # Technology to use. hammer-vlsi will read this and load the appropriate technology libraries.
  technology: "hammer.technology.nop"

  node: 0 # Technology node dimension (nm) to use.
  # Some tools change what they do as this changes.
  # TODO: move this to vlsi.technology (or technology.core) ucb-bar/hammer#317

  build_system: "none" # Build system to use, if any.
  # This is used to auto-generate a build file, if desired. It is not required to run hammer.
  # Valid options are "none" or "make"

  # Synthesis tool to use.
  # Currently, we can choose from a selection of built-in tools which hammer-vlsi supports.
  synthesis_tool: "hammer.synthesis.nop"

  # Place and route tool to use.
  par_tool: "hammer.par.nop"

  # DRC tool to use.
  drc_tool: "hammer.drc.nop"

  # LVS tool to use.
  lvs_tool: "hammer.lvs.nop"

  # SRAM Generator tool to use.
  sram_generator_tool: "hammer.sram_generator.nop"

  # Sim tool to use.
  sim_tool: "hammer.sim.mocksim"

  # Power analysis tool to use.
  power_tool: "hammer.power.nop" # TODO: doesn't exist

  # Formal verification/check tool to use.
  formal_tool: "hammer.formal.nop" # TODO: doesn't exist

  # Static timing analysis tool to use.
  timing_tool: "hammer.timing.nop" # TODO: doesn't exist

  # PCB deliverable tool to use.
  pcb_tool: "hammer.pcb.generic"
  # PCB deliverables include footprints, symbols, etc.
  # For the exact deliverables produced, please see the deliverable tool's documentation.
  # For the default 'generic' tool, the list of artefacts can be found in src/hammer-vlsi/pcb/generic/__init__.py

  max_threads: 1 # Maximum threads to use in a CAD tool invocation.

vlsi.technology:
# TODO ucb-bar/hammer#317 move these to technology.core (discussion to be had)
  placement_site: null # Placement site for macros. (Optional[str])
  # Typically specified in standard cell LEFs.
  # See http://www.ispd.cc/contests/18/lefdefref.pdf
  # Required for some CAD tools to function properly.

  bump_block_cut_layer: null # Top cut/via layer for blockage under bumps. (Optional[str])
  # Only used if using vlsi.inputs.bumps
  # TODO: remove this after stackup supports vias ucb-bar/hammer#354

  extra_libraries: [] # Extra semiconductor IP libraries/stdcell libs/hard macros. (List[ExtraLibrary])
  # Used for non-technology-vendor-provided custom IP blocks.
  # ExtraLibrary is a struct with two fields:
  # - prefix (Optional[PathPrefix]) - struct that holds a prefix and path.
  #   - path (str) - Path for the prefix below.
  #     For example, if the path is /foo/bar/pll, then a reference of pll/test.txt (assuming 'pll' is the prefix) will
  #     resolve to /foo/bar/pll/test.txt.
  #   - prefix (str) - prefix used for referencing in the library.
  #     For example, if "lef file" in HammerLibrary references "pll/layout/pll.lef", then the path would be "pll".
  # - library (hammer_tech.HammerLibrary) - IP library to add.
  # Extra libraries are added at the end of the library list, in the event that order matters.

  extra_macro_sizes: [] # Extra information about macro sizes.
  # type: List[MacroSize]
  # MacroSize is a struct with the following fields:
  # - library (str): IP library of the macro. Leave blank if unknown
  # - name (str): Name of the macro block
  # - width (float): Width of the macro in um
  # - height (float): Height of the macro in um

  extracted_tarballs_dir: null
  # Path where tarballs have been extracted.
  # type: Optional[str]
  # Note: this setting can be specified per-technology using
  # technology.<tag>.extracted_tarballs_dir as well.
  # The technology-specific setting takes precedence if it exists.
  # For example, if the technology plugin defines a tarball foobar.tar.gz,
  # and this is set to /opt/test, then /opt/test/foobar.tar.gz/ should contain
  # the extracted contents of foobar.tar.gz.
  # If this is not specified, then the tarballs will be extracted to obj/<tech_dir>/extracted/.

  timing_lib_pref: "NLDM"
  # Select a timing lib preference, available options include:
  # NLDM, ECSM, and CCS (lower or upper case acceptable). 
  # If no preference is specified, then the following preference order is followed:
  # NLDM -> ECSM -> CCS

# General VLSI inputs.
# These will vary per run of hammer-vlsi.
vlsi.inputs:
  # Supply voltages and names
  # Supply Struct:
  #   name (str) - The name of your supply's net
  #   pin (Optional[str]) - The cell pin that this net should drive, no pins are connected when omitted
  #   tie (Optional[str]) - Another supply this supply is tied to. Nets with this set will  not end up in your final layout.
  #   weight (Optional[int]) - The weight of this supply when building power straps (larger number = more straps).
  #     Not used for grounds. Mandatory, but defaults to 1 if omitted.
  supplies:
    power: [{name: "VDD", pin: "VDD"}] # power (List(Supply)): A list of of all power net(s) in the design
    ground: [{name: "VSS", pin: "VSS"}] # ground (List(Supply)): A list of all ground net(s) in the design
    VDD: "0.85 V" # VDD (str): The default voltage of the primary power net
    GND: "0 V" # GND (str): The default voltage of the primary ground net

  hierarchical:
    mode: flat # Hierarchical par mode. (str)
    # Valid options:
    # flat - Perform a flat place and route run.
    # leaf - Leaf module in a hierarchical run - same as flat except that an extra write_ilm step is added.
    # hierarchical - Module which has sub-modules which are also hierarchical.
    # top - Top module in a hierarchical run - runs an extra assemble_design step.

    top_module: "null" # Top RTL module in the hierarchical flow. (str)
    # Not to be confused with synthesis.inputs.top_module which specifies the synthesis module for this run.
    # (e.g. synthesis.inputs.top_module is used for a sub-synthesis run)

    config_source: none # Used by HammerDriver to generate configurations for hierarchical place-and-route.
    # type: (str)
    # Valid options:
    # none - Do nothing. (default)
    # manual - Read from hierarchical_manual_* below.
    # from_placement - Generate from "hierarchical" entries in vlsi.inputs.placement_constraints.

    manual_modules: [] # Manual hierarchical definitions used only if hierarchical_definition_source is set to manual mode.
    # Should be a list along the lines of [{"module1": "module1_sub1", "module1_sub2", "module2": "module2_sub"}].

    manual_placement_constraints: [] # Manual hierarchical placement constraints used only if hierarchical_definition_source is set to manual mode.
    # Should be a list along the lines of [{"module1": <list of PlacementConstraint structs>}].

    constraints: [] # Manual hierarchical constraints. Overrides generic constraints on a per module basis.
    # Should be a list along the lines of [{"module1": <list of other hammer constraints>}].
    # For example [{"mod1": [vlsi.inputs.default_output_load: 2], "mod2": [vlsi.inputs.clocks:<clock constraints>] }].

  ilms: [] # ILMs for hierarchical mode.
  # ILM struct (ILMStruct) members:
  # dir (str) - directory to the ILMs (...ILMDir)
  # data_dir (str) - data directory to the ILMs (...ILMDir/mmmc/...)
  # module (str) - module name for the ILM
  # lef (str) - path to the LEF file
  # gds (str) - path to the GDS file
  # netlist (str) - path to the netlist file
  # sim_netlist (str) - Optional. If specified, this netlist is appended for hierarchical simulation

  mmmc_corners: [] # Multi-mode multi-corner setups, overrides supplies
  # MMMC struct members:
  # name (str) - name of the corner.
  # type (str) - One of the following:
  # - "setup" (corner used for setup timing)
  # - "hold" (corner used for hold timing)
  # - "extra" (misc. corner, e.g. nominal for power analysis)
  # voltage (str) - voltage of the corner should match tech json
  # temp (str) - temperature of the corner should match tech json

  clocks: [] # Clock ports of the top-level module.
  # type: List[ClockPort]
  # TODO: support multiply_by in generated clocks
  # Clock struct members:
  # name (str) - Name of the clock port.
  # period (TimeValue) - Clock port period. e.g. "1 ns", "5ns". Default units: ns
  # path (str) - Optional. If specified, this is the RTL path to the clock. Otherwise, the path is the same as the name.
  # uncertainty (TimeValue) - Optional. Clock uncertainty. e.g. "1 ns", "5ns". Default units: ns
  # generated (bool) - Optional. If specified this clock is generated from another clock, must specify source_path and divisor
  # source_path (str) - Required if generated. The path of the clock that this clock is generated from.
  # divisor (int) - Required if generated. The amount this generated clock is slowed from the source clock e.g. 2 => this clock will be two times slower than the source clock.
  #   We are constrained to integers by SDC.
  # group (str) - Optional. The name of the clock group this clock belongs to. Clocks in the same group will not be marked as asynchronous.
  #   Clocks with no group specified will all be placed in separate groups and thus marked as asynchronous to each other and all other groups.

  default_output_load: 1 # Default output pin load capacitance.
  # Default: 1pF

  output_loads: [] # List of output load constraints.
  # Each item in the list should be a struct with the following members:
  # name (str) - Name of the output load (e.g. io_out)
  # load (float) - Output load capacitance in pF.

  delays: [] # List of delay constraints.
  # These either constrain inputs to arrive after a certain delay relative
  # to the clock or constrain outputs to arrive a certain delay before
  # the clock edge.
  # Each item in the list should be a struct with the following members:
  # name (str) - Name of the I/O being delayed.
  # clock (str) - Name of the clock that this delay is based on.
  # direction (str) - Gives the direction of the I/O. Should be one of:
  # - "input"
  # - "output"
  # delay (TimeValue) - Delay applied to the I/O.

  custom_sdc_constraints: [] # List of custom sdc constraints to use. (List[str])
  # These are appended after all other generated constraints (clock, pin, delay, load, etc.).

  placement_constraints: [] # List of placement constraints for floorplanning.
  # Each item is a struct member:
  # path (str) - Path to the given instance
  # - Required for all types
  # type (str) - The type of placement constraint
  # - Required for all types
  # - One of the following:
  #   - "dummy" (does nothing with this constraint)
  #   - "placement" (creates a placement constraint for an instance)
  #   - "toplevel" (top-level chip dimensions; may only occur once, for the top-level module)
  #   - "hardmacro" (places this hard macro at a particular spot)
  #   - "hierarchical" (marks this instance as part of hierarchical place and route)
  #   - "obstruction" (creates a blockage at a particular spot; see obs_types)
  #   - "overlap" (places this overlapping macro at a particular spot but does not add any halos/obstructions)
  # orientation (Optional[str]) - The orientation
  # - Optional for all types
  # - Valid options:
  #   - "r0"   (standard orientation)
  #   - "r90"  (rotated 90 degrees clockwise)
  #   - "r180" (rotated 180 degrees)
  #   - "r270" (rotated 270 degrees clockwise; equivalent to -90 degrees counterclockwise)
  #   - "mx"   (mirrored about the x-axis)
  #   - "mx90" (mirrored about the x-axis, then rotated 90 degrees clockwise)
  #   - "my"   (mirrored about the y-axis)
  #   - "my90" (mirrored about the y-axis, then rotated 90 degrees clockwise)
  # x (float) - x coordinate in um
  # - Required for all types
  # y (float) - y coordinate in um
  # - Required for all types
  # width (float) - width in um
  # - Required for all types, but can be auto-filled for hierarchical, hardmacro, and overlap if left blank
  # height (float) - height in um
  # - Required for all types, but can be auto-filled for hierarchical, hardmacro, and overlap if left blank
  # master (Optional[str]) - The master module name of the hierarchical, hardmacro, or overlap constraint.
  #                          For example, if this hardmacro is an instance of "my_amplifier", this
  #                          field should be set to "my_amplifier".
  # - Required for hierarchical and optional for hardmacro and overlap, disallowed otherwise
  # create_physical (Optional[bool]) - Create an instance of a physical-only cell that does not exist in addition to placing it
  # - Optional for hardmacro and overlap, disallowed otherwise
  # margins (Optional[Margins]) - margins for the top-level module.
  # - Required for toplevel, disallowed otherwise
  # - Contains the following keys:
  #   - "left"   (margin from the left side of the core PNR area to the edge of the chip)
  #   - "right"  (margin from the right side of the core PNR area to the edge of the chip)
  #   - "top"    (margin from the top side of the core PNR area to the edge of the chip)
  #   - "bottom" (margin from the bottom side of the core PNR area to the edge of the chip)
  # top_layer (str) - Specifies the highest layer used by this hierarchical or hardmacro, used to keep other wires away
  # - Optional for hierarchical and hardmacro, disallowed otherwise
  # layers (List[str]) - A list of strings that enumerates layer(s) blocked by the obstruction otherwise all layers are blocked
  # - Required for the obstruction type, disallowed otherwise
  # obs_types (List[str]) - A list of the types of obstructions for the given geometry
  # - Required for the obstruction type, disallowed otherwise
  # - A list of one or more of the following:
  #   - "place" - This obstruction type stops the placement of standard cells inside it
  #   - "route" - This obstruction type stops all routing inside it
  #   - "power" - This obstruction type stops only power routing/straps inside it

  dont_use_mode: auto # Don't use list mode. (str)
  # Specifies where to get the list of cells to not use.
  # These cells can be specified in a number of ways:
  # - "MY_CELL" (cell MY_CELL in any library)
  # - "*/MY_CELL" (cell MY_CELL in any library)
  # - "*CELL" (any cell that ends with CELL in any library)
  # - "*_CELL_*" (any cell that matches the wildcard *_CELL_* in any library)
  # - "CELL_*_IVX" (any cell that matches the wildcard CELL_*_IVX in any library)
  # - "MY_LIB/*" (any cell under the library MY_LIB)
  # - "MY_LIB/CELL*" (any cell that matches the wildcard CELL* under the library MY_LIB)
  # Valid options:
  # auto - Use the technology plugin's value for the don't use list
  # manual - Use the list from the variable below, overriding the technology plugin
  # append - Append the manual list to the technology plugin's list
  dont_use_list: [] # Optional: List of cells to mark as don't use
  # type: List[str]

  power_spec_mode: empty # Power specification mode. (str)
  # Specifies how to obtain a power specificaiton. Power specifications often setup
  # how many power nets you have, what their names and voltages are, as well as
  # how many domains you have and what their relation is.
  # Valid options:
  # auto - Hammer will generate a power specification based on other settings,
  #        including vlsi.inputs.supplies.
  # manual - Use the value given in power_spec_contents with type given in power_spec_type
  # empty - Do not use any power specification
  power_spec_type: null # Optional: Power specification type. (str)
  # Specifies what kind/version/type of power specification to use
  # Valid options:
  # cpf - Use the common power format commonly used in Cadence tools
  # upf - Use the universal power format, IEEE 1801-2015
  power_spec_contents: null # Optional: Contents of a power specification in the above type (str)

  sram_parameters: [] # SRAM Parameters

  bumps_mode: empty # Bumps settings mode. (str)
  # Specifies how to setup the bumps for your design.
  # Currently only support rectangular, evenly-spaced grids
  # Bumps are numbered starting with 1,1 in the lower left
  # Unassigned bumps will be removed, bumps with no_connect set will be present but unconnected
  # Valid options:
  # manual - Use the bumps struct to create and assign bumps
  # empty - Do not add any bumps

  bumps:
  # Bumps settings struct only required if above key is set to manual
  # BumpsDefinition struct members
    x: 0 # x (int) - number of bumps in the x dimension
    y: 0 # y (int) - number of bumps in the y dimension
    # pitch (float) - pitch of bumps in microns
    # Overrideable by appending _<dim name>
    # type: float
    pitch: 0.0
    global_x_offset: 0.0 # offset the bump map in the x-axis (float)
    global_y_offset: 0.0 # offset the bump map in the y-axis (float)    
    cell: "" # cell (str) - Name of the default bump cell
    assignments: [] # assignments - List of BumpAssignment structs. You must specify one of name or no_connect.
    # If both are specified the bump will be left unconnected
    #  - name (Optional[str]) - The name of the net being assigned to a bump
    #  - no_connect (Optional[bool]) - If True the bump will be present but unconnected
    #  - x (Decimal) - The X coordinate of the bump assigned to this net
    #  - y (Decimal) - The Y coordinate of the bump assigned to this net
    #  - group (Optional[str]) - The group name for the bumps
    #                          - The schematic symbol generator will put all bumps in a group on the same part or sub-component.
    #  - custom_cell (Optional[str]) - Cell name (MACRO name) of a custom bump cell in place of the default for this bump. You must also specify the LEF and GDS for this bump in extra_libraries.

  bumps_pin_naming_scheme: "A1" # Naming scheme for the bumps' actual physical pin designators
  # Valid options are
  # - "A0"    (Use letters for rows, skipping I, O, Q, S, X, and Z. After Y is AA, AB, AC ...
  #            Use numbers for columns, starting at 0, with no leading 0s (0-9, then 10, 11, ...))
  # - "A1"    (Like A0, but numbers start at 1)
  # - "A00"   (Like A0, but all bumps will have the same number of digits, with leading 0s appended if needed.
  #            E.g. if there are 555 columns, The top row will start at A000 and end at A554)
  # - "A01"   (Like A00, but numbers start at 1)
  # - "index" (Just returns a single number in the order the bumps are listed- useful for non-grid designs)
  # type: str

  pin_mode: none # Pin placement mode. (str)
  # Specifies how to arrange pins for your design.
  # Valid options:
  # none - This mode lets the CAD tool do whatever it wants (providing no constraints).
  #   Typically this is sane but unpredictable.
  # generated - Use the assignments list below
  # auto - (not implemented yet) looks at the hierarchy and guess where pins should go
  pin:
    generate_mode: full_auto # Pin generation modes.
    # type: str
    # Valid options are:
    # - full_auto: auto-place minimum-width pins (intended for digital signals) along a side. This option is the default.
    # - semi_auto: enables the auto-place features above but also optionally allows pin width, depth, and locations to
    #   be manually specified.

    assignments: [] # List of PinAssignment Structs.
    #   You must specify pins and one of either preplaced or layers and side.
    # - pins (str) - The name(s) of pins that will be assigned. All current backends support
    #   * as wildcards in the pin names. So "*" for all pins or "io_tl_a*" for all pins that
    #   start with "io_tl_a".
    # - side (Optional[str]) - The side of the chip/block these pins will be placed along.
    #   One of:
    #   - left, right, top, bottom
    #   - internal: creates an internal pin with `location` as its *center*.
    #     Requires the semi_auto pin generation mode.
    #   If left unspecified, the CAD tool may choose an arbitrary side to use (likely the closest side).
    # - layers (Optional[List[str]]) - The metal layers that these pins will be placed on.
    # - preplaced (Optional[bool]) - If true, these pins are preplaced by some internal block or macro.
    #   This is telling the tool that these pins are on an internal block and I want them
    #   "placed" where they are currently on the internal block. This can be used for IP
    #   that directly connects to bumps, or signals that will be connected by abutment,
    #   and much more.
    # - location (Optional[Tuple[float, float]]) - specifies the *center* (x, y) location of the pin on the specified
    #   edge.
    #   If side is one of left/right/top/bottom, this specifies the point that lies on the edge that is used for
    #   width/depth control. Below is an example of location if side is "top":
    #
    #   -------X------- (chip/block edge)
    #   |             |
    #   ---------------
    #
    #   If side is "internal", then this specifies the absolute *center* of the
    #   Requires the semi_auto pin generation mode.
    # - width (Optional[float]) - specifies a custom width for the pin. The width direction is orthogonal to the routing
    #   direction.
    #   Requires the semi_auto pin generation mode.
    # - depth (Optional[float]) - specifies a custom depth for the pin. The depth direction is parallel to the routing
    #   direction.
    #   Requires the semi_auto pin generation mode.

  decaps: [] # List of decap constraints (DecapConstraint struct).
  # These are used for finer-grained control over how decap cells are placed.
  # Decap cells can be targeted for a certain density or total capacitance.
  # A specific area constraint can be specified with x, y, width, and height.
  # Each item in the list should be a struct with the following members:
  # target (str) - Targets a specific density or total capacitance. Should be one of:
  # - "density"
  # - "capacitance"
  # density (Optional[Decimal]) - Target density between 0 and 1. Must be used with target: "density".
  # capacitance (Optional[CapacitanceValue]) - Target total capacitance. Must be used with target: "capacitance".
  # x (Optional[Decimal]) - x-coordinate of area constraint
  # y (Optional[Decimal]) - y-coordinate of area constraint
  # width (Optional[Decimal]) - width of area constraint
  # height (Optional[Decimal]) - height of area constraint
  # Note that either none or all of x, y, width, and height must be specified in a constraint struct.

  visualization:
  # SVG visualization of placement constraints and bumps for the current hierarchical module.
  # Used by the generate_visualization method accessible by all HammerTools.
    mode: "all" # Type of visualization to draw
    # Note: pcb action will mirror visualization across y-axis (assumes flip-chip on PCB)
    # Valid options:
    # - all: draws all placement constraints, bumps, and pad designators (if running pcb action)
    # - floorplan: draws only placement constraints
    # - bumps: draws only bumps
    # - footprint: draws PCB footprint, only valid if running pcb action
    # type: str
    svg_file: "${vlsi.inputs.visualization.mode}.svg" # Name of the desired output SVG file
    # type: str
    svg_file_meta: lazysubst
    shorten_path_depth: 1 # Depth of paths to shorten for better readability in the SVG
    # E.g. top/path/to/inst will shorten to t/p/t/inst for depth of 1 and t/p/top/inst for depth of 2
    # A depth of 0 or less will perform no path shortening.
    # type: int

vlsi.submit:
  command: "local" # The submit command to use. "none", "local", or null will run on the current host. See hammer_submit_command.py for other options.
  settings: [] # type: List[Dict[str, Dict[str, Any]]]
  # The list substitutes settings in order of appearance, and the first Dict key is the command.
  # The second dict key is the name of that command's setting, followed by whatever type it takes.

synthesis.inputs:
# Specific inputs for the synthesis tool.
# These inputs are the generic inputs; specific tools ("CAD junk") may require
# additional inputs.
# They will vary per run of hammer-vlsi.
  input_files: [] # Input files.
  # Typically a list of Verilog/VHDL files, depending on the synthesis tool.

  top_module: null # Top RTL module.
  # Set to null to not specify from the JSON.

synthesis:
# Syntheis tool settings
  clock_gating_mode: auto # Clock gating mode.
  # type: str
  # This tells the tool how to handle clock gating.
  # Valid options:
  # auto - Turn on automatic clock gating inference in CAD tools.
  # empty - Do not do any clock gating.

synthesis.submit:
# inherit settings from vlsi.submit but allow us to override them
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

par.inputs:
# Specific inputs for the place and route tool.
# These inputs are the generic inputs; specific tools ("CAD junk") may require
# additional inputs.
# They will vary per run of hammer-vlsi.
  input_files: [] # Input post-synthesis netlist files.
  # Typically a list of Verilog/VHDL files, depending on the tool.
  # For place and route, these should typically be post-synthesis netlists.

  top_module: null # Top RTL module.

  post_synth_sdc: null # Optional: SDC input file from post-synthesis.
  # Leave as null to not use.

  gds_map_mode: auto # GDS output map mode.
  # type: str
  # The GDS map file shows how/what layers should be put in the GDSII file.
  # Valid options:
  # auto - Use the technology plugin's value for the map file.
  # empty - Don't use a map file at all and let the cad tool do what it wants.
  #         This often results in a complete but arbitrary assignment.
  # manual - Read the map file from the variable below, overriding the technology plugin.
  gds_map_file: null # Optional: GDS map file path. Used only if gds_map_mode above is set to manual.
  # type: Optional[str]

  # If true, tell the place and route tool to merge any library/macro GDSes into
  # the final GDS.
  # type: bool
  gds_merge: false

  physical_only_cells_mode: auto # Physical only cells mode.
  # type: str
  # The list of physical only cells are cells which don't have a logic function.
  # They won't have a SPICE circuit for instance.
  # This is currently only used for what cells to exclude from the LVS netlist, which
  # requires SPICE circuits for all cells.
  # Valid options:
  # auto - Use the technology plugin's value for the physical cell list.
  # manual - Read the physical cell list from the variable below, overriding the technology plugin.
  # append - Append the manual list to the technology plugin's list
  physical_only_cells_list: [] # List of cells that are only physical.
  # type: List[str]

  gds_precision_mode: "auto" # GDS output precision. Controlled by a mode and a precision value. Valid modes are:
  # auto - perform default PAR-tool behaviour, which is usually to use the
  #        value specified in the LEF.
  # manual - use the value from the 'par.inputs.gds_precision' key below.
  # type: str

  gds_precision: 1000 # GDS output precision when written by PAR tool. Some tools restrict the
  # value to a limited range and your tool plugin should check this for you.
  # Innovus, for example, restricts values to one of {100, 200, 1000, 2000,
  # 10000, 20000}. This value is ignored if 'par.inputs.gds_precision_mode' is
  # not manual.
  # type: int

par:
# Place-and-route settings
  # Submission command settings
  # inherit settings from vlsi.submit but allow us to override them
  submit:
    command: "${vlsi.submit.command}"
    command_meta: lazysubst
    settings: "vlsi.submit.settings"
    settings_meta: lazycrossref

  power_straps_mode: empty # Power straps configuration.
  # Valid options are:
  # - empty - Specify no power straps
  # - manual - Specify the contents of a manual TCL script to use, specified in power_straps_script_contents.
  # - generate - Generate power straps from Hammer IR.
  power_straps_script_contents: null

  blockage_spacing: 0.0 # Spacing around blocks and hardmacros in microns
  # Used by power straps and floorplanning
  # type: Decimal

  blockage_spacing_top_layer: null # Top metal layer that is pulled back around blocks and hardmacros
  # Used by floorplanning.
  # Overridden by individual placement constraints on top_layer.
  # type: Optional[str]

  generate_power_straps_method: "by_tracks" # If power_straps_mode is 'generate', which method to use.
  # Currently, the valid options are:
  # - by_tracks - Specify the power strap plan per layer in terms of tracks

  generate_power_straps_options:
  # Default settings for power strap generation modes
  # Keys are the valid values of the 'generate_power_straps_method' key above
    by_tracks:
      blockage_spacing: "par.blockage_spacing" # Spacing from end of strap to a block or blockage
      # Overrideable by appending _<layer name>
      # type: Decimal
      blockage_spacing_meta: lazycrossref

      track_width: 5 # Number of routing tracks to be consumed by an individual strap
      # Overrideable by appending _<layer name>
      # type: int

      track_start: 0 # The first track to contain a power stripe
      # Overrideable by appending _<layer name>
      # type: int
      # TODO(johnwright): include an auto-center option

      track_offset: 0.0 # Absolute offset for straps relative to the design bounding box origin
      # Overrideable by appending _<layer name>
      # type: Decimal

      track_spacing: 0 # Number of routing tracks between sets of straps (0 is recommended)
      # Overrideable by appending _<layer name>
      # type: int

      power_utilization: 0.1 # Ratio of total routing tracks to dedicate to power straps, which is used to calculate set pitch
      # Overrideable by appending _<layer name>
      # type: float

      pin_layers: [] # Layers to put power pins on
      # type: List[str]

      strap_layers: [] # List of layers on which to place power straps (std cell rail layer is implied - do not include it)
      # type: List[str]

# DRC settings
drc.inputs:
# DRC settings
  top_module: null # Top RTL module.
  # type: str

  layout_file: null # Input layout file.
  # Typically a GDSII file from the place and route tool.
  # type: str

  additional_drc_text_mode: "auto" # Valid modes are auto, manual, prepend, and append
  # type: str
  additional_drc_text: "" # Custom DRC command text to add after the boilerplate commands at the top of the run file.
  # type: str

  drc_rules_to_run: [] # DRC rules to run.
  # Leaving this empty will run all rules - otherwise, the rules listed will be run.
  # Rule names are defined in the Design Rule Manual (DRM).
  # Generally rules will still have the same names across DRC decks for different tool vendors from the same PDK.
  # There is no "schema" for the DRC rule names in Hammer - while the vendors may have some pattern they use, this
  # setting has no understanding of that.
  # type: List[str]

drc.submit:
# inherit settings from vlsi.submit but allow us to override them
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

lvs.inputs:
# LVS settings
  top_module: null # Top RTL module.

  layout_file: null # Input layout file
  # Typically a GDSII file from the place and route tool

  schematic_files: [] # Input list of schematic files

  ilms: [] # Input list of ILMStructs

  hcells_list: [] # Input list of LVS Hcells

  additional_lvs_text_mode: "auto" # Valid modes are auto, manual, prepend, and append
  additional_lvs_text: "" # Custom LVS command text to add after the boilerplate commands at the top of the run file

lvs.submit:
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

sram_generator.submit:
# inherit settings from vlsi.submit but allow us to override them
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

pcb.inputs:
# PCB deliverable settings.
  top_module: null # Top RTL module.

pcb.submit:
  # Submission command settings
  # inherit settings from vlsi.submit but allow us to override them
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

technology.core:
    stackup: null # Key name for the technology stackup
    # This should exist in the stackups list in the tech json
    # type: str
    special_cells: null # Key name for the technology's special cells
    # This should exist in the special_cells list in the tech json
    # type: str
    std_cell_rail_layer: null # This should specify the TOPMOST metal layer the standard cells use for power rails
    # Note that this is not usually stackup specific; it is based on the std cell library
    # type: str
    tap_cell_rail_reference: null # This is used to provide a reference master for generating standard cell rails
    # Can be a wildcard/glob
    # type: str
    std_cell_supplies:
    # Names of the power and ground rails of the standard cells
        power: ["VDD"]
        ground: ["VSS"]

# Specific inputs for the simulation tool.
# These inputs will vary based on if the simulation is for RTL, post synthesis, or post PAR.
# There may be HAMMER simulation tool plugins available that include common simulator flags and inputs that can be modified/augmented for the user's needs.
sim.inputs:
  top_module: null # Top RTL module for simulation
  # type: str

  input_files: [] # Input files for simulation including verilog sources, testharness/testbench, etc.
  # type: List[str]

  options: [] # Permissive options for the simulator generation
  # These options will appear as plain string option additions when generating the simulation executable
  # type: List[str]

  defines: [] # Define options passed when generating the simulation executable
  # For example: when passed to VCS, each define in the input list will be added as "+define+" + {define}
  # type: List[str]

  compiler_cc_opts: [] # C compiler options used when generating the simulation executable
  # For example: when passed to VCS, each compiler_cc_opt will be added as "-CC " + {compiler_cc_opt}
  # type: List[str]

  compiler_ld_opts: [] # C linker options used when generating the simulation executable
  # For example: when passed to VCS, each compiler_ld_opt will be added as "-LDFLAGS " + {compiler_ld_opt}
  # type: List[str]

  timescale: null # Simulation timescale
  # This is passed as a plain string
  # For example, for VCS, timescale may be set as "sim.inputs.timescale: '1ns/10ps' which would be passed as "-timescale=1ns/10ps"
  # type: str

  benchmarks: [] # Benchmarks to run with the simulator executable
  # This is a list of paths to benchmark binaries that will be run with the simulator to test the design if the testbench requires it.
  # For example, this may be a RISCV binary like rv64ui-p-simple.
  # If left empty, the simulation will execute as normal.
  # type: List[str]

  parallel_runs: 1 # Maximum number of simulations to run in parallel.
  # A value of -1 indicates all simulations should be launched in parallel
  # A value of 0 and 1 are treated the same and all simulations are run serially
  # type: int

  tb_dut: "dut" # Hierarchical path to the top level instance of the "dut" from the testbench.
  # For example, this will be used to generate the hierarchical path through the testbench and DUT to each sequential element in the design.
  # TODO(johnwright) automate this by parsing the TB verilog?
  # type: str

  tb_name: "TestDriver" # Name of the simulation testbench/test driver module

  level: "rtl" # Simulation mode for simulation at different levels of the VLSI flow
  # Valid options are:
  #   "rtl" for rtl level simulation
  #   "syn" for post-synthesis level simulation
  #   "par" for post-par level simulation
  # type: FlowLevel

  all_regs: "" # Path to a list of all registers in the design passed from synthesis or place-and-route
  # type: str

  seq_cells: "" # Path to a list of all sequential standard cells in the design passed from synthesis or place-and-route
  # type: str

  sdf_file: null # SDF File
  # type: str
  # Standard Delay Format file for use in timing annotated sims
  # leave as null if not in use

  gl_register_force_value: 0 # Simulation force value used for register initialization for gate level sims
  # TODO: add random initialization option
  # type: int

  timing_annotated: false # Turns time annotated sim on or off
  # type: bool
  # If set to False, the sim will be purely functional, regardless of the simulation "level".
  # If set to True, the sim will be time annotated based on synthesis or PAR results.

  # Settings related to activity file (SAIF) dumping
  saif:
    mode: "none" # How Hammer determines whether and when to start or stop the activity dumping
    # Valid options:
    # time - Start dumping at the specified start_time and end at the specified end_time
    # trigger - Inserts the trigger into the simulators run script before starting the dump and
    #   after enabling dumping before stopping dumping. See your simulator plugin for an example
    # trigger_raw - Inserts the given tcl directly into the simulators run script with no checking.
    # full - Start dumping at the beginning of simulation and stop at the end.
    # none - Do not dump an SAIF
    # type: str
    start_time: "0ns" # The times the simulator should begin and end its dumping of the SAIF file.
    # type: TimeValue
    end_time: "1ns" # type: TimeValue
    start_trigger_raw: "" # The raw triggers that will occur when the dump should start and when the dump should end.
    # The exact trigger format will depend on the underlying tool.
    # type: str
    end_trigger_raw: ""

  execution_flags: [] # Flags to run with the simulator
  # Each string in this list will be passed as an option when actually executing the simulation executable generated from the previous arguments.
  # type: List[str]

  execution_flags_prepend: [] # Flags that are to be pre-pended to the simulator execution flags in "execution_flags"
  # type: List[str]

  execution_flags_append: [] # Flags that are to be appended to the simulator execution flags in "execution_flags"
  # type: List[str]

  execute_sim: true # Determines whether or not the simulation executable that is generated with the above inputs will actually be executed with the given flags or if the executable will just be generated in the specified run directory.
  # type: bool

sim.submit:
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

power.inputs:
# Specific inputs for the power tool.
# These may vary based on the specific tool plugin
  top_module: "ChipTop" # Top RTL module for power analysis
  # type: str

  database: null # The path to a synthesis or place-and-route database of the design to be analyzed
  # type: str

  tb_name: "TestDriver" # The name of the test bench from the simulation.
  # type: str

  tb_dut: "dut" # The name of the device under test (DUT) from the simulation.
  # type: str

  spefs: [] # The paths of all spef (extraction) files needed for the design.
  # This may include a file per MMMC corner
  # type: List[str]

  waveforms: [] # A list of paths to waveforms to be used for dynamic power analysis.
  # Depending on the sim & power tool, these may be VCD/VPD, FSDB, SHM, etc. files/dirs.
  # type: List[str]

  saifs: [] # A list of paths to SAIF activity files to be used for dynamic power analysis.
  # type: List[str]

  extra_corners_only: false # If overridden to ``true``, the power tool will report for only the extra MMMC corners, saving runtime.
  # The typical use case is to only report power and rail analysis for a typical/nominal corner.
  # type: bool

  input_files: [] # A list of the paths to the design inputs files (HDL or netlist) for power analysis
  # type: List[str]

  sdc: "" # SDC input file
  # type: str

  report_configs: [] # Optional: Power report configs that are run in addition to the average power reports in power.inputs.waveforms
  # type: List[PowerReport]
  # PowerReport struct members:
  # waveform_path (str) - Path to the waveform for the report
  # module (str) - Optional. the path to the module to report power for (default here is the Chipyard top level)
  # levels (int) - Optional. the number of levels in the design hierachy to report
  # start_time (str) - Optional. The start time of the power report in the waveform
  # end_time (str) - Optional. The end time of the power report in the waveform
  # toggle_signal (str) - Optional. Path to the signal to generate report windows based on toggles
  # num_toggles (int) - Optional (must be specified if num_toggles is specified). The number of toggles of the toggle_signal for each frame to report power
  # frame_count (int) - Optional. The number of frames to report the power for
  # report_name (str) - Optional. Name of the power report
  # example: report_configs: [{waveform_path: "/path/to/fsdb", module: "chiptop", levels:3, start_time: "0ns", end_time: "1ns", toggle_signal:"/ChipTop/clock", num_toggles:1, frame_count:1000, report_name: "my_fsdb_report"}]

  level: "rtl" # Power analysis mode for different levels of the VLSI flow
  # Valid options are:
  #   "rtl" for rtl level power analysis
  #   "syn" for post-syn power analysis
  #   "par" for post-par power analysis
  # type: FlowLevel

  start_times: [] # Optional: A list of analysis start times corresponding to each waveform used for dynamic power analysis.
  # type: Optional[List[str]]

  end_times: [] # Optional: A list of analysis end times corresponding to each waveform used for dynamic power analysis.
  # type: Optional[List[str]]

power.submit:
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

formal.inputs:
# Specific inputs for the formal tool.
# These may vary based on the specific tool plugin.
# For example, files could be combinations of Verilog, Liberty, Spice, CPF, and/or SDC files.
  check: "lec" # Check type to run. Support varies based on the specific tool plugin.
  # Potential options (see tool plugin defaults.yml for supported checks):
  # - lec: logical equivalence checking (supported)
  # - power: power intent (CPF/UPF) and structure checking (not yet supported)
  # - constraint: design constaint (SDC) checking (not yet supported)
  # - cdc: clock domain crossing checking (not yet supported)
  # - property: contention, tristate, don't care, etc. checking (not yet supported)
  # - eco: engineering change order generation (not yet supported)
  # type: str

  input_files: [] # Input files.
  # Typically a list of Verilog/VHDL files, depending on the formal tool.
  # For equivalence checking, this is commonly referred to as the "revised" design.
  # type: List[str]

  reference_files: [] # The reference (golden) design files for equivalence checks
  # type: List[str]

  top_module: null # Top RTL module for running verification on
  # type: str

formal.submit:
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

timing.inputs:
# Specific inputs for the timing tool.
# These may vary based on the specific tool plugin.
  input_files: [] # Input Verilog files.
  # type: List[str]

  top_module: null # Top RTL module.
  # Set to null to not specify from the JSON.

  post_synth_sdc: null # Optional: SDC input file from post-synthesis.
  # type: Optional[str]

  spefs: null # Optional: Input SPEF files from post-P&R.
  # type: Optional[List[str]]

  sdf_file: null # Optional: Input SDF file
  # type: Optional[str]

  max_paths: 100 # Max paths to report
  # type: int

timing.submit:
  command: "${vlsi.submit.command}"
  command_meta: lazysubst
  settings: "vlsi.submit.settings"
  settings_meta: lazycrossref

technology.pcb:
  bump_pad_opening_diameter: null # Desired pad opening diameter (in post-shrink um)
  # Typically this should be defined in the technology plugin, assuming everyone will use the same pad and board strategy
  # type: Decimal

  bump_pad_metal_diameter: null # Desired pad metal diameter (in post-shrink um)
  # Typically this should be defined in the technology plugin, assuming everyone will use the same pad and board strategy
  # type: Decimal
