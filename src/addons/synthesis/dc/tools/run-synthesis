#!/bin/bash

unset run_dir
unset dc
unset rmtar
libs=()
mw=()
unset top
v=()
tlu_min=()
tlu_max=()
tf=()
unset find_regs
unset config
unset technology
while [[ "$1" != "" ]]
do
    case "$1" in
    "$0") ;;
    --output_dir) run_dir="$2"; shift;;
    */dc_shell) dc="$1";;
    */DC-RM_*.tar) rmtar="$1";;
    *.db) libs+=("$1");;
    */lib) mw+=("$(dirname "$1")");;
    --top) top="$2"; shift;;
    *.v) v+=("$1");;
    *Cmin.tluplus) tlu_min+=("$1");;
    *Cmax.tluplus) tlu_max+=("$1");;
    *rcbest.itf.tluplus) tlu_min+=("$1");;
    *rcworst.itf.tluplus) tlu_max+=("$1");;
    */FuncCmin/tluplus) tlu_min+=("$1");;
    */FuncCmax/tluplus) tlu_max+=("$1");;
    *.tf) tf+=("$1");;
    */find-regs.tcl) find_regs="$1";;
    *.syn_config.json) config="$1";;
    *.tech.json) technology="$1";;
    *) echo "Unknown argument $1"; exit 1;;
    esac
    shift
done

set -ex

rm -rf "$run_dir"
mkdir -p "$run_dir"

cat >"$run_dir"/enter <<EOF
export DC_HOME="$(dirname $(dirname $dc))"
export PATH="\$DC_HOME/bin:\$PATH"
export MGLS_LICENSE_FILE="$MGLS_LICENSE_FILE"
export SNPSLMD_LICENSE_FILE="$SNPSLMD_LICENSE_FILE"
EOF

# Almost all of what I do is to just use Synopsys's reference methodology,
# which users are expected to have downloaded.
tar -xf "$rmtar" -C "$run_dir" --strip-components=1
mkdir -p $run_dir/generated-scripts

# The default DC script has an "exit" an the end, which we want to strip off so
# I can add more commands after all the RM DC stuff.
sed 's/^exit$//g' -i $run_dir/rm_dc_scripts/dc.tcl

# This variable is set in "dc_setup.tcl", which for some reason we're expected
# to edit inside this file in addition to setting it up inside the setup file
# above.  Instead I just remove this second definition, as it's pretty useless.
sed 's/^set RTL_SOURCE_FILES .*$//' -i $run_dir/rm_setup/dc_setup.tcl

# Here's another thing that the scripts overwrite but that I want to set
sed 's/^set DCRM_CONSTRAINTS_INPUT_FILE .*$//' -i $run_dir/rm_setup/dc_setup_filenames.tcl

# I don't want to write ICC2 files
sed 's/^write_icc2_files .*$//' -i $run_dir/rm_dc_scripts/dc.tcl

# FIXME: We aren't licensed for "DC-Extension" so we can't pass "-congestion"
# or "-spg" to compile_ultra
find $run_dir -iname "*.tcl" | xargs sed s/'^compile_ultra \(.*\)-congestion\(.*\)'/'compile_ultra \1 \2'/g -i
find $run_dir -iname "*.tcl" | xargs sed s/'^compile_ultra \(.*\)-spg\(.*\)'/'compile_ultra \1 \2'/g -i

# Run a check before compile_utlra, as that gives better messages when
# something is wrong.
find $run_dir -iname "*.tcl" | xargs sed s/'^compile_ultra \(.*\)'/'compile_ultra -check_only \1\ncompile_ultra \1'/g -i

# Report more timing arcs
sed 's@^report_timing@report_timing -max_paths 500 -nworst 10 -slack_lesser_than 0.01@' -i $run_dir/rm_dc_scripts/dc.tcl

# Report library references in case I'm missing anything.
sed "s@^check_design @report_reference > reports/${top}.report_reference.out\\ncheck_design @" -i $run_dir/rm_dc_scripts/dc.tcl

if [[ "${mw[@]}" == "" ]]
then
    echo "No milkyway libraries specified"
    exit 1
fi

for lib in "${mw[@]}"
do
    if test ! -d "$lib"
    then
        echo "Milkyway library $lib doesn't exist in filesystem" >&2
	exit 1
    fi
done

if [[ "${tlu_max[*]}" == "" || "${tlu_min[*]}" == "" ]]
then
    echo "No TLU+ files specified"
    exit 1
fi

if [[ "$PLSI_SCHEDULER_MAX_THREADS" == "" ]]
then
    export PLSI_SCHEDULER_MAX_THREADS="1"
fi

# Most of the customization of the DC reference methodology is done here: this
# sets all the input files and such.
mkdir -p $run_dir/rm_setup
cat >> $run_dir/rm_setup/common_setup.tcl <<EOF
set DESIGN_NAME "$top";
set RTL_SOURCE_FILES "$(readlink -f ${v[@]})";
set TARGET_LIBRARY_FILES "$(readlink -f ${libs[@]})";
set MW_REFERENCE_LIB_DIRS "$(readlink -f ${mw[@]})";
set MIN_LIBRARY_FILES "";
set TECH_FILE "$(readlink -f ${tf[@]})";
set TLUPLUS_MAX_FILE "$(readlink -f ${tlu_max[@]})";
set TLUPLUS_MIN_FILE "$(readlink -f ${tlu_min[@]})";
set ALIB_DIR "alib";
set DCRM_CONSTRAINTS_INPUT_FILE "generated-scripts/constraints.tcl"
set REPORTS_DIR "reports";
set RESULTS_DIR "results";
set CLOCK_UNCERTAINTY "0.04";
set INPUT_DELAY "0.10";
set OUTPUT_DELAY "0.10";
set_host_options -max_cores ${PLSI_SCHEDULER_MAX_THREADS}
EOF

# Read the core's configuration file to figure out what all the clocks should
# look like.
python3 >>$run_dir/generated-scripts/constraints.tcl <<EOF
import json
with open("${config}") as f:
	config = json.load(f)

import re
for clock in config["clocks"]:
	clock_name = clock["name"]
	clock_period = clock["period"]
	if not re.match("[0-9]+ *[np]s", clock_period):
		error

	if re.match("[0-9]+ *ns", clock_period):
		clock_period_ns = re.sub(" *ns", "", clock_period)
	if re.match("[0-9]+ *ps", clock_period):
		clock_period_ns = int(re.sub(" *ps", "", clock_period)) / 1000.0

	print("create_clock {0} -name {0} -period {1}".format(clock_name, clock_period_ns))
	print("set_clock_uncertainty 0.01 [get_clocks {0}]".format(clock_name))
EOF

# The constraints file determines how the IO is constrained and what the clocks
# look like.
cat >> $run_dir/generated-scripts/constraints.tcl <<"EOF"
# set drive strength for inputs
#set_driving_cell -lib_cell INVD0BWP12T [all_inputs]
# set load capacitance of outputs
set_load -pin_load 0.004 [all_outputs]

#set all_inputs_but_clock [remove_from_collection [all_inputs] [get_ports clock]]
#set_input_delay 0.02 -clock [get_clocks clock] $all_inputs_but_clock
#set_output_delay 0.03 -clock [get_clocks clock] [all_outputs]

#set_isolate_ports [all_outputs] -type buffer
#set_isolate_ports [remove_from_collection [all_inputs] clock] -type buffer -force
EOF

# We allow users to specify metal routing directions since some technologies
# don't support those.
python3 >>$run_dir/generated-scripts/constraints.tcl <<EOF
import json
with open("${technology}") as f:
	config = json.load(f)

for library in config["libraries"]:
	if "metal layers" in library:
		for layer in library["metal layers"]:
			print("set_preferred_routing_direction -layers {{ {0} }} -direction {1}".format(layer["name"], layer["preferred routing direction"]))
EOF

# FIXME: This is a terrible way to specify the retiming registers, it should
# come from a FIRRTL pass.
for x in $(echo "IntToFP" "FPUFMAPipe" "Mul54" "INToRecFN" "IMulSlice" "FMASlice" "FCmpSlice" "FConvSlice" "DivSqrtRecF64" "IMul")
do
    grep "^module $x" ${v[*]} && (echo "set_optimize_registers true -design $x* -clock clock -check_design -verbose -print_critical_loop" >> $run_dir/generated-scripts/constraints.tcl)
done

# FIXME: This shouldn't depend on Synopsys
# At the end of the DC run we want to generate a special simulation file that
# tells VCS to set all the generated registers to 0.  I was hoping that
# "+vcs+initreg+0" would do this, but it doesn't look like it does.
cat >> $run_dir/rm_dc_scripts/dc.tcl <<EOF
source ${find_regs}
find_regs $top 0 \${RESULTS_DIR}/$top.force_regs.ucli \${RESULTS_DIR}/$top.force_regs.tab
EOF

# Here's the actual DC invocation
echo "exit" >> $run_dir/rm_dc_scripts/dc.tcl
cd $run_dir
$dc -topographical_mode -f rm_dc_scripts/dc.tcl \
    |& tee dc.log

# FIXME: This definately shouldn't have "dut" hard-coded here, and shouldn't
# rely on sed.
case "$top" in
ExampleTop)
  sed s/$top/testHarness.ExampleTop_1/g -i $run_dir/results/$top.force_regs.ucli
  ;;
Counter)
  sed s/$top/dut/g -i $run_dir/results/$top.force_regs.ucli
  ;;
*)
  echo "Ununkown top $top"
  exit 1
  ;;
esac

# Make sure there's no invalid output from DC
set +e
grep ^Warning dc.log && (echo "DC produced warning messages")
grep ^Error dc.log && (echo "DC produced error messages"; exit 1)
exit 0
